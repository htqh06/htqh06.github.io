<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>javaguide</title>
    <link href="/2025/04/10/javaguide/"/>
    <url>/2025/04/10/javaguide/</url>
    
    <content type="html"><![CDATA[<h2 id="java基础">Java基础</h2><h3 id="值传递">值传递</h3><pre><code class="hljs">不像C++有引用传递，java中全部都是值传递，函数拿到的全是原变量的副本</code></pre><h3 id="java序列化">java序列化</h3><pre><code class="hljs">将数据结构或对象转换成可以存储或传输的形式，通常是二进制字节流，也可以是 JSON, XML 等文本格式  发生在OSI七层模型中的表示层，对应于TCP四层协议的应用层  OSI七层：应用层，表示层，会话层，传输层，网络层，数据链路层，物理层  </code></pre><h3 id="代理模式">代理模式</h3><pre><code class="hljs"> 我们使用代理对象来代替对真实对象(real object)的访问，这样就可以在不修改原目标对象的前提下，提供额外的功能操作，扩展目标对象的功能。代理模式的主要作用是扩展目标对象的功能，比如说在目标对象的某个方法执行前后你可以增加一些自定义的操作。  </code></pre><h3 id="bigdecimal">BigDecimal</h3><pre><code class="hljs">BigDecimal 可以实现对小数的运算，不会造成精度丢失</code></pre><h2 id="集合">集合</h2><pre><code class="hljs">Java 集合，也叫作容器，主要是由两大接口派生而来：一个是 Collection接口，主要用于存放单一元素；另一个是 Map 接口，主要用于存放键值对。对于Collection 接口，下面又有三个主要的子接口：List、Set 、 Queue  集合中的collection主要用来存储数值，而MAP用于存储键值对  所以，我们在需要存储数值时，选用collection，而需要存储键值对时，我们选用Map  在选取collection时：  如果我们需要需要保证元素唯一时选择实现 Set 接口的集合比如 TreeSet 或 HashSet，不需要就选择实现 List 接口的比如 ArrayList 或 LinkedList。  </code></pre><h3 id="list">List</h3><pre><code class="hljs">List分为ArrayList和Linklist  对于插入：头部插入：由于需要将所有元素都依次向后移动一个位置，因此时间复杂度是 O(n)。  尾部插入：当 ArrayList 的容量未达到极限时，往列表末尾插入元素的时间复杂度是 O(1)，因为它只需要在数组末尾添加一个元素即可；当容量已达到极限并且需要扩容时，则需要执行一次 O(n) 的操作将原数组复制到新的更大的数组中，然后再执行 O(1) 的操作添加元素。  指定位置插入：需要将目标位置之后的所有元素都向后移动一个位置，然后再把新元素放入指定位置。这个过程需要移动平均 n/2 个元素，因此时间复杂度为 O(n)。  对于删除：  头部删除：由于需要将所有元素依次向前移动一个位置，因此时间复杂度是 O(n)。   尾部删除：当删除的元素位于列表末尾时，时间复杂度为 O(1)。  指定位置删除：需要将目标元素之后的所有元素向前移动一个位置以填补被删除的空白位置，因此需要移动平均 n/2 个元素，时间复杂度为 O(n)。  </code></pre>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>French Learning</title>
    <link href="/2025/03/27/French-Learning/"/>
    <url>/2025/03/27/French-Learning/</url>
    
    <content type="html"><![CDATA[<h2 id="imparfait-未完成过去时">imparfait 未完成过去时</h2><ol type="1"><li><p>描述背景 当叙述过去的故事时，imparfait常用于描写环境、天气、心情或人物的背景。例如： “Il faisaitbeau.”（天气很好。）</p></li><li><p>进行中的动作用来表达过去某个时间段内正在进行的动作，而不是一个明确开始或结束的动作。例如：“Je lisais quand tu as téléphoné.”（你打电话时我正在看书。）</p></li><li><p>习惯性或反复动作 描述过去经常发生或习惯性的行为。例如： Chaqueété, nous allions à la plage.（每年夏天，我们都会去海滩。）</p></li><li><p>描述状态 用于表达过去人物的情感或身体状态。例如：<br />“Il était très fatigué.”（他当时非常疲惫。）</p></li></ol><h3 id="变位语法">变位语法</h3><ol type="1"><li>取动词的“nous”形式（复数第一人称）的词干（去掉 -ons 结尾）</li><li>加上以下人称专用的未完成过去时词尾： je -ais<br />tu -ais<br />il/elle/on -ait<br />nous -ions<br />vous -iez<br />ils/elles -aient<br />举例：<br />Parle: Nous的变位：parlons-&gt;parl je: parlais</li></ol><h2 id="复合过去时">复合过去时</h2>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>Distribute_Database</title>
    <link href="/2025/03/21/Distribute-Database/"/>
    <url>/2025/03/21/Distribute-Database/</url>
    
    <content type="html"><![CDATA[<h2 id="第一节ppt">第一节PPT</h2><h2 id="nosql-database">NoSql Database</h2><p>CAP- Conisitency, Avalablity， Torlerance to network Partitions<br />三个标准很难同时满足，传统的Relational database只能满足c和a<br />很多distribued database会去满足A和P</p><p>batch access:将多条数据请求或操作合并在一个批次中一次性执行。例如，在数据库中，可以通过批量插入或更新来减少与数据库的交互次数，从而提高整体性能。<br />比如说可以设置当有100条插入操作之后，再去统一执行操作，</p><p>1.Graph Database<br />类似于E-R图，用节点代表数据实体，用边表示数据实体之间的关系。</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>Data base</title>
    <link href="/2025/03/09/Data-base/"/>
    <url>/2025/03/09/Data-base/</url>
    
    <content type="html"><![CDATA[<h2 id="introduction">Introduction</h2><p>DB和DBMS:一个数据库和一个软件（管理多个数据库）</p><p>数据模型（Data Model）：<br />- ER图:数据关系描述的更清晰 - 关系模型（Relation Model）：可读性更强</p><p>A 3 levels data description:<br />External Schema（用户层）-&gt;Conceptualschema（逻辑结构，常用ER图）-&gt;Physicalschema（DBMS管理，内部层，物理存储）</p><p>DBMS<br />DDL：数据定义语言 定义数据库结构<br />DML：数据库操作语言，增删改查：SELECT, INSERT, UPDATE DELETE</p><h2 id="relational-model-and-relational-algebra">Relational Model andRelational Algebra</h2><ol type="1"><li>笛卡尔积：AXB<br /><code>SQL: SELECT * FROM table1，table2</code></li><li>关系：整个表就是一个关系：属性attribute（列），元组tuple（行），域（Domain）表示某个属性的取值范围，主键PrimaryKey：可以唯一标识一个元组的字段，外键：在一个表中引用另一个表的主键，用来建立表之间的关系</li></ol><p>关系代数： 1. 并（union） 2. 交（intersection） 3. 差（Difference）4. 笛卡尔积 5. 选择： <span class="math display">\[   \sigma_{model = &#39;db&#39; \ and \ age \ &gt;15} (Students)   \]</span> 6. 投影： <span class="math display">\[   \pi_{addreee}(Student)   \]</span> 7. join:按条件合并两表的行（实际是选择 +笛卡尔积的组合⨝<br /><code>SELECT * FROM Students</code><code>JOIN Enrollments ON Students.id = Enrollments.student_id</code> 8.Division除：</p><h2 id="sql语句">sql语句</h2><p>如果想要表示或者怎么办：使用union语句将两个select联合在一起<br />如：Give the id of movies released before 1930 or having actor’s id 12in their casting.<br /><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">select</span> c.movieid<br><span class="hljs-keyword">from</span> castings c<br><span class="hljs-keyword">where</span> c.actorid <span class="hljs-operator">=</span> <span class="hljs-number">12</span> <br><span class="hljs-keyword">union</span><br><span class="hljs-keyword">select</span> m.id<br><span class="hljs-keyword">from</span> movies m<br><span class="hljs-keyword">where</span> m.year <span class="hljs-operator">&lt;</span> <span class="hljs-number">1930</span><br></code></pre></td></tr></table></figure> 字符串匹配 用like ‘%abc%’,即 字符串中含有abc的<br />在某个中in(), 不在某个中not in()</p><p>用来找两个不同的演员，自连接： <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> <span class="hljs-keyword">DISTINCT</span> m.id, m.title <br><span class="hljs-keyword">FROM</span> movies m, castings c1, castings c2 <br><span class="hljs-keyword">WHERE</span> m.id<span class="hljs-operator">=</span>c1.movieid <span class="hljs-keyword">AND</span> m.id<span class="hljs-operator">=</span>c2.movieid <br><span class="hljs-keyword">AND</span> c1.actorid<span class="hljs-operator">&lt;&gt;</span>c2.actorid <br><span class="hljs-keyword">AND</span> m.yr<span class="hljs-operator">=</span><span class="hljs-number">2000</span> <br></code></pre></td></tr></table></figure> 在代码中<code>c1.actorid&lt;&gt;c2.actorid</code>引入了两个表，表示c1的id不等于c2的id，即有两个即以上不同的演员</p><p>max：max返回的是最大值，例如max(salary)返回的就是最大薪水的值，所以，如果想要用找拥有最大薪水员工的信息，可以用子查询如： <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">select</span> <span class="hljs-operator">*</span><br><span class="hljs-keyword">from</span> employee<br><span class="hljs-keyword">where</span> salary <span class="hljs-operator">=</span> (<span class="hljs-keyword">select</span> <span class="hljs-built_in">max</span>(salary)<br>                  <span class="hljs-keyword">from</span> employee)<br></code></pre></td></tr></table></figure> group by:搭配count使用，在 GROUP BY中，一组就是一行，每组只投影一次，count可以计数groupby中每个组的行数<br />having：HAVING 是用来对 GROUP BY 分组后的结果 进行筛选的，而 HAVINGCOUNT(…) 就是：筛选出那些组内“行数”符合条件的分组<br />学会使用子查询来满足条件<br />如果要找同一个表中不同的实体拥有相同的属性，可以先取这个表做一个自连接，如r1.n&lt;&gt;r2.n,然后再筛选想要的属性 如 List of the hotels with theiraddress and category, having at least 2 of rooms with the same price.<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">select</span> h.address, h.cat<br><span class="hljs-keyword">from</span> hotel h, room r1, room r2<br><span class="hljs-keyword">where</span> r1.nroom <span class="hljs-operator">&lt;&gt;</span> r2.nroom<br><span class="hljs-keyword">and</span> r1.price <span class="hljs-operator">=</span> r2.price<br><span class="hljs-keyword">and</span> h.hotel <span class="hljs-operator">=</span> r1.hotel<br></code></pre></td></tr></table></figure> ### 关系视图View（视图）是基于一个或多个表构建的虚拟表，它本身不存储数据，只是一个查询的结果集。用户可以像访问普通表一样访问视图。<br />你有一个大表 employees，你创建一个视图只看“财务部员工”： <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">VIEW</span> finance_employees <span class="hljs-keyword">AS</span><br><span class="hljs-keyword">Select</span> e.name, e.id<br><span class="hljs-keyword">from</span> employee e<br><span class="hljs-keyword">where</span> e.type <span class="hljs-operator">=</span> <span class="hljs-string">&#x27;money&#x27;</span><br></code></pre></td></tr></table></figure>你以后可以用： <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> finace_employees<br>...<br></code></pre></td></tr></table></figure> 视图(View)可以用来权限控制：<br />Give access rights not to an entire table, but to a view defined on thistable 赋予和删除访问权限 <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">Grant</span> <span class="hljs-operator">&lt;</span>rights<span class="hljs-operator">&gt;</span><br><span class="hljs-keyword">on</span> <span class="hljs-operator">&lt;</span>object<span class="hljs-operator">&gt;</span><br><span class="hljs-keyword">to</span> <span class="hljs-keyword">user</span><br><span class="hljs-keyword">REVOKE</span> <span class="hljs-operator">&lt;</span>rights<span class="hljs-operator">&gt;</span><br> <span class="hljs-keyword">ON</span> <span class="hljs-operator">&lt;</span>object<span class="hljs-operator">&gt;</span><br> <span class="hljs-keyword">FROM</span> <span class="hljs-operator">&lt;</span><span class="hljs-keyword">user</span><span class="hljs-operator">&gt;</span><br></code></pre></td></tr></table></figure></p><h2 id="er图和uml类图">ER图和UML类图</h2><p>在ER图中，关系两边的数字代表每个实体参与这个关系的最小值和最大值，如：<br />emplpyee (1,1)———-菱形works for————–(0,n)department<br />代表每个雇员必须至少参与这个关系一次，最多也参与一次<br />而(0,n)代表每个部门最少雇佣0名员工，最多雇佣n名员工<br />通过主键和外键的来确定某几个实体之间的联系</p><h2 id="规范化normalization">规范化(Normalization)</h2><h3 id="函数依赖functional-dependency">函数依赖(Functionaldependency)</h3><p>一组属性 B 函数依赖于另一组属性 A，当且仅当：在任意合法的数据记录中，每一组 A 的值，唯一对应一组 B 的值。 即知道A，就能唯一确定 B。 这时，我们叫做 B依赖A<br />X → Y 的意思是： Y 依赖于 X，也可以说：X 决定 Y<br />Armstrong’s Axioms：</p><h3 id="部分依赖第二范式2nf">部分依赖（第二范式2NF）</h3><p>如果一个非主属性依赖于主键的一部分（而不是整个复合主键），那么这种依赖叫做部分依赖。 例如在选课成绩表中，主键是学号+课程<br />而表中拥有学生姓名这一属性，学生姓名只依赖于学号而不依赖于课程<br />这就是部份依赖<br />在第二范式中，只要求所有非主属性没有依赖主键的一部分，即满足2NF ###传递依赖（第三范式3NF） 非主属性依赖另一个非主属性（再依赖主键）例如在关系R(学生id，学院，院长)中<br />我们设置学生id为主键，学院依赖学生id FD: 学生id-&gt;学院<br />院长依赖学院：FD:学院-&gt;院长<br />构成了传递依赖关系，因此不符合3NF<br />### 第一范式 每个字段都是原子值,例如：<br />001 张三 138xxxx8888,139xxxx7777<br />电话号码”这一列包含了多个值，违反原子性。</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>YAGO论文学习</title>
    <link href="/2025/03/06/YAGO%E8%AE%BA%E6%96%87%E5%AD%A6%E4%B9%A0/"/>
    <url>/2025/03/06/YAGO%E8%AE%BA%E6%96%87%E5%AD%A6%E4%B9%A0/</url>
    
    <content type="html"><![CDATA[<h2 id="introduction">Introduction</h2><p>Knowledge Base(KnwoledgeGraph)是一个有向标签多重图（两个节点之间允许有多条边）</p><p>相比与WikiData，YAGO 4 KB结合了WiKiData的instance和Schema.org的分类</p><p>方便进行推理(Resoning)</p><p>WiKidata采用Class,有很多用户自己定义的复杂类类别。<br />YAGO采用多个属性(Properity)的组合，方便推理，但是如果有些非常规类别名，则很难搜索。</p><p>在这篇论文中，作者尝试结合WiKidata和YAGO的优点，即YAGO采用Schema.org,拥有比较清晰的上层分类(Uppertaxonomy)结构，而Wikidata的下层分类(lower taxonomy)更具细节.</p><h2 id="designing-yago">Designing YAGO</h2><ol type="1"><li>prefer properties over class membership</li><li>Choose the property with fewer objects.</li><li>The upper taxonomy exists to define formal properties that will bepopulated</li><li>The lower taxonomy exists to convey human-intelligible informationabout its instances in a non-redundant form.</li></ol>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>Network Program学习笔记</title>
    <link href="/2025/03/03/Network-Program%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    <url>/2025/03/03/Network-Program%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
    
    <content type="html"><![CDATA[<h1 id="network-programing-学习笔记">Network Programing 学习笔记</h1><h2 id="考试形式">考试形式</h2><p>实验+考试，考试主要是理论</p><h2id="tcp协议的socket的函数调用流程">TCP协议的Socket的函数调用流程</h2><p><img src="/pic/1.png" alt="img" /><br />函数展示, 服务端 <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdlib.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unistd.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/socket.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;netinet/in.h&gt;</span></span><br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-type">int</span> server_fd, client_fd;<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">sockaddr_in</span> <span class="hljs-title">address</span>;</span><br>    <span class="hljs-type">int</span> addrlen = <span class="hljs-keyword">sizeof</span>(address);<br><br>    <span class="hljs-comment">// 1. 创建套接字</span><br>    server_fd = socket(AF_INET, SOCK_STREAM, <span class="hljs-number">0</span>);<br>    <span class="hljs-keyword">if</span> (server_fd == <span class="hljs-number">-1</span>) &#123;<br>        perror(<span class="hljs-string">&quot;socket failed&quot;</span>);<br>        <span class="hljs-built_in">exit</span>(EXIT_FAILURE);<br>    &#125;<br><br>    <span class="hljs-comment">// 2. 绑定端口</span><br>    address.sin_family = AF_INET;<br>    address.sin_addr.s_addr = INADDR_ANY;<br>    address.sin_port = htons(<span class="hljs-number">8080</span>);<br>    <span class="hljs-keyword">if</span> (bind(server_fd, (<span class="hljs-keyword">struct</span> sockaddr*)&amp;address, <span class="hljs-keyword">sizeof</span>(address)) &lt; <span class="hljs-number">0</span>) &#123;<br>        perror(<span class="hljs-string">&quot;bind failed&quot;</span>);<br>        <span class="hljs-built_in">exit</span>(EXIT_FAILURE);<br>    &#125;<br><br>    <span class="hljs-comment">// 3. 监听连接</span><br>    <span class="hljs-keyword">if</span> (listen(server_fd, <span class="hljs-number">5</span>) &lt; <span class="hljs-number">0</span>) &#123;<br>        perror(<span class="hljs-string">&quot;listen failed&quot;</span>);<br>        <span class="hljs-built_in">exit</span>(EXIT_FAILURE);<br>    &#125;<br><br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Server listening on port 8080...\n&quot;</span>);<br><br>    <span class="hljs-comment">// 4. 接受连接并处理</span><br>    <span class="hljs-keyword">while</span> (<span class="hljs-number">1</span>) &#123;<br>        client_fd = accept(server_fd, (<span class="hljs-keyword">struct</span> sockaddr*)&amp;address, (<span class="hljs-type">socklen_t</span>*)&amp;addrlen);<br>        <span class="hljs-keyword">if</span> (client_fd &lt; <span class="hljs-number">0</span>) &#123;<br>            perror(<span class="hljs-string">&quot;accept failed&quot;</span>);<br>            <span class="hljs-keyword">continue</span>;<br>        &#125;<br><br>        <span class="hljs-comment">// 5. 数据通信</span><br>        <span class="hljs-type">char</span> buffer[<span class="hljs-number">1024</span>] = &#123;<span class="hljs-number">0</span>&#125;;<br>        read(client_fd, buffer, <span class="hljs-keyword">sizeof</span>(buffer));<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Client: %s\n&quot;</span>, buffer);<br><br>        <span class="hljs-type">char</span> *response = <span class="hljs-string">&quot;Message received!&quot;</span>;<br>        send(client_fd, response, <span class="hljs-built_in">strlen</span>(response), <span class="hljs-number">0</span>);<br><br>        close(client_fd);<br>    &#125;<br><br>    close(server_fd);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure> 客户端<br /><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdlib.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unistd.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/socket.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;netinet/in.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;arpa/inet.h&gt;</span></span><br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-type">int</span> client_fd;<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">sockaddr_in</span> <span class="hljs-title">server_addr</span>;</span><br><br>    <span class="hljs-comment">// 1. 创建套接字</span><br>    client_fd = socket(AF_INET, SOCK_STREAM, <span class="hljs-number">0</span>);<br>    <span class="hljs-keyword">if</span> (client_fd == <span class="hljs-number">-1</span>) &#123;<br>        perror(<span class="hljs-string">&quot;socket failed&quot;</span>);<br>        <span class="hljs-built_in">exit</span>(EXIT_FAILURE);<br>    &#125;<br><br>    <span class="hljs-comment">// 2. 连接服务器</span><br>    server_addr.sin_family = AF_INET;<br>    server_addr.sin_port = htons(<span class="hljs-number">8080</span>);<br>    inet_pton(AF_INET, <span class="hljs-string">&quot;127.0.0.1&quot;</span>, &amp;server_addr.sin_addr);<br><br>    <span class="hljs-keyword">if</span> (connect(client_fd, (<span class="hljs-keyword">struct</span> sockaddr*)&amp;server_addr, <span class="hljs-keyword">sizeof</span>(server_addr)) &lt; <span class="hljs-number">0</span>) &#123;<br>        perror(<span class="hljs-string">&quot;connect failed&quot;</span>);<br>        <span class="hljs-built_in">exit</span>(EXIT_FAILURE);<br>    &#125;<br><br>    <span class="hljs-comment">// 3. 发送和接收数据</span><br>    <span class="hljs-type">char</span> *message = <span class="hljs-string">&quot;Hello, Server!&quot;</span>;<br>    send(client_fd, message, <span class="hljs-built_in">strlen</span>(message), <span class="hljs-number">0</span>);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Message sent: %s\n&quot;</span>, message);<br><br>    <span class="hljs-type">char</span> buffer[<span class="hljs-number">1024</span>] = &#123;<span class="hljs-number">0</span>&#125;;<br>    read(client_fd, buffer, <span class="hljs-keyword">sizeof</span>(buffer));<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Server response: %s\n&quot;</span>, buffer);<br><br>    close(client_fd);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure></p><h2 id="udp协议的socket函数创建流程">UDP协议的socket函数创建流程</h2><p><img src="/pic/UDP-structure.png" alt="img" /><br />相比与TCP协议，在服务端中UDP省去了accept(),客户端中省去了Connect()这两个建立连接的过程。是一个无连接协议<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdlib.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unistd.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/socket.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;netinet/in.h&gt;</span></span><br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-type">int</span> sockfd;<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">sockaddr_in</span> <span class="hljs-title">server_addr</span>, <span class="hljs-title">client_addr</span>;</span><br>    <span class="hljs-type">socklen_t</span> client_len = <span class="hljs-keyword">sizeof</span>(client_addr);<br>    <span class="hljs-type">char</span> buffer[<span class="hljs-number">1024</span>];<br><br>    <span class="hljs-comment">// 1. 创建UDP套接字</span><br>    sockfd = socket(AF_INET, SOCK_DGRAM, <span class="hljs-number">0</span>);<br>    <span class="hljs-keyword">if</span> (sockfd == <span class="hljs-number">-1</span>) &#123;<br>        perror(<span class="hljs-string">&quot;socket creation failed&quot;</span>);<br>        <span class="hljs-built_in">exit</span>(EXIT_FAILURE);<br>    &#125;<br><br>    <span class="hljs-comment">// 2. 绑定地址和端口</span><br>    server_addr.sin_family = AF_INET;<br>    server_addr.sin_addr.s_addr = INADDR_ANY;<br>    server_addr.sin_port = htons(<span class="hljs-number">8080</span>);<br>    <span class="hljs-keyword">if</span> (bind(sockfd, (<span class="hljs-keyword">struct</span> sockaddr*)&amp;server_addr, <span class="hljs-keyword">sizeof</span>(server_addr)) &lt; <span class="hljs-number">0</span>) &#123;<br>        perror(<span class="hljs-string">&quot;bind failed&quot;</span>);<br>        <span class="hljs-built_in">exit</span>(EXIT_FAILURE);<br>    &#125;<br><br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;UDP Server listening on port 8080...\n&quot;</span>);<br><br>    <span class="hljs-keyword">while</span> (<span class="hljs-number">1</span>) &#123;<br>        <span class="hljs-comment">// 3. 接收数据（需保存客户端地址）</span><br>        <span class="hljs-type">ssize_t</span> bytes_received = recvfrom(sockfd, buffer, <span class="hljs-keyword">sizeof</span>(buffer), <span class="hljs-number">0</span>, <br>                                        (<span class="hljs-keyword">struct</span> sockaddr*)&amp;client_addr, &amp;client_len);<br>        <span class="hljs-keyword">if</span> (bytes_received &lt; <span class="hljs-number">0</span>) &#123;<br>            perror(<span class="hljs-string">&quot;recvfrom failed&quot;</span>);<br>            <span class="hljs-keyword">continue</span>;<br>        &#125;<br>        buffer[bytes_received] = <span class="hljs-string">&#x27;\0&#x27;</span>;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Received from client: %s\n&quot;</span>, buffer);<br><br>        <span class="hljs-comment">// 4. 发送响应</span><br>        <span class="hljs-type">char</span> *response = <span class="hljs-string">&quot;Hello from UDP server&quot;</span>;<br>        sendto(sockfd, response, <span class="hljs-built_in">strlen</span>(response), <span class="hljs-number">0</span>, <br>             (<span class="hljs-keyword">struct</span> sockaddr*)&amp;client_addr, client_len);<br>    &#125;<br><br>    close(sockfd);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure> 客户端： <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdlib.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unistd.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/socket.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;netinet/in.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;arpa/inet.h&gt;</span></span><br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-type">int</span> sockfd;<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">sockaddr_in</span> <span class="hljs-title">server_addr</span>;</span><br>    <span class="hljs-type">char</span> buffer[<span class="hljs-number">1024</span>];<br><br>    <span class="hljs-comment">// 1. 创建UDP套接字</span><br>    sockfd = socket(AF_INET, SOCK_DGRAM, <span class="hljs-number">0</span>);<br>    <span class="hljs-keyword">if</span> (sockfd == <span class="hljs-number">-1</span>) &#123;<br>        perror(<span class="hljs-string">&quot;socket creation failed&quot;</span>);<br>        <span class="hljs-built_in">exit</span>(EXIT_FAILURE);<br>    &#125;<br><br>    <span class="hljs-comment">// 2. 设置服务器地址</span><br>    server_addr.sin_family = AF_INET;<br>    server_addr.sin_port = htons(<span class="hljs-number">8080</span>);<br>    inet_pton(AF_INET, <span class="hljs-string">&quot;127.0.0.1&quot;</span>, &amp;server_addr.sin_addr);<br><br>    <span class="hljs-comment">// 3. 发送数据（无需连接）</span><br>    <span class="hljs-type">char</span> *message = <span class="hljs-string">&quot;Hello from UDP client&quot;</span>;<br>    sendto(sockfd, message, <span class="hljs-built_in">strlen</span>(message), <span class="hljs-number">0</span>, <br>         (<span class="hljs-keyword">struct</span> sockaddr*)&amp;server_addr, <span class="hljs-keyword">sizeof</span>(server_addr));<br><br>    <span class="hljs-comment">// 4. 接收响应</span><br>    <span class="hljs-type">ssize_t</span> bytes_received = recvfrom(sockfd, buffer, <span class="hljs-keyword">sizeof</span>(buffer), <span class="hljs-number">0</span>, <span class="hljs-literal">NULL</span>, <span class="hljs-literal">NULL</span>);<br>    <span class="hljs-keyword">if</span> (bytes_received &lt; <span class="hljs-number">0</span>) &#123;<br>        perror(<span class="hljs-string">&quot;recvfrom failed&quot;</span>);<br>        <span class="hljs-built_in">exit</span>(EXIT_FAILURE);<br>    &#125;<br>    buffer[bytes_received] = <span class="hljs-string">&#x27;\0&#x27;</span>;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Server response: %s\n&quot;</span>, buffer);<br><br>    close(sockfd);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure> ## 查询语句 1.查询服务<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-keyword">struct</span> servent* <span class="hljs-title function_">getservbyname</span><span class="hljs-params">( <span class="hljs-type">const</span> <span class="hljs-type">char</span> *name,  <span class="hljs-type">const</span> <span class="hljs-type">char</span> *proto )</span><br><span class="hljs-keyword">struct</span> servent *<span class="hljs-title function_">getservbyport</span><span class="hljs-params">( intport,  constchar *proto )</span><br><span class="hljs-comment">//返回指向对应servent结构体的指针</span><br></code></pre></td></tr></table></figure> 2.查询协议 <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">protoent</span>&#123;</span> <br>    <span class="hljs-type">char</span> *p_name; <span class="hljs-comment">/* official protocolname*/</span> <br>    <span class="hljs-type">char</span> **p_aliases; <span class="hljs-comment">/* alias list*/</span> <br>    intp_proto; <span class="hljs-comment">/* protocolnumber*/</span> <br>&#125; <br><span class="hljs-keyword">struct</span> protoent *<span class="hljs-title function_">getprotobyname</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span> *name)</span>;<br><span class="hljs-keyword">struct</span> protoent *<span class="hljs-title function_">getprotobynumber</span><span class="hljs-params">(<span class="hljs-type">int</span> proto)</span>;<span class="hljs-comment">//通过协议号查询</span><br></code></pre></td></tr></table></figure> 3.查询主机 <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">hostent</span>&#123;</span> <br>    <span class="hljs-type">char</span> *h_name; <span class="hljs-comment">/* official name of host */</span> <br>    <span class="hljs-type">char</span> **h_aliases; <span class="hljs-comment">/* alias list */</span> <br>    inth_addrtype; <span class="hljs-comment">/* host address type */</span> <br>    inth_length; <span class="hljs-comment">/* length of address */</span> <br>    <span class="hljs-type">char</span> **h_addr_list; <span class="hljs-comment">/* list of addresses */</span> <br>&#125;<br><span class="hljs-keyword">struct</span> hostent *<span class="hljs-title function_">gethostbyname</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span> *name)</span>;<br><span class="hljs-keyword">struct</span> hostent*<span class="hljs-title function_">gethostbyaddr</span><span class="hljs-params">(constvoid*addr,socklen_tlen, <span class="hljs-type">int</span> type)</span>;<br></code></pre></td></tr></table></figure> ##广播（Broadcast）和组播(Multicast)</p><p>广播 强制所有设备接收，无论是否需要。分为limited broadcast address255.255.255.255和子网广播例如192.168.1.255<br />缺点：可能引发“广播风暴”，浪费带宽和计算资源。 <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-comment">//启动广播权限</span><br><span class="hljs-type">int</span> broadcastPermission = <span class="hljs-number">1</span>;<br>setsockopt(sock, SOL_SOCKET, SO_BROADCAST, &amp;broadcastPermission, <span class="hljs-keyword">sizeof</span>(broadcastPermission));<br><span class="hljs-comment">//发送广播数据</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">sockaddr_in</span> <span class="hljs-title">broadcastAddr</span>;</span><br>broadcastAddr.sin_family = AF_INET;<br>broadcastAddr.sin_addr.s_addr = inet_addr(<span class="hljs-string">&quot;255.255.255.255&quot;</span>);<br>broadcastAddr.sin_port = htons(<span class="hljs-number">12345</span>);<br>sendto(sock, data, len, <span class="hljs-number">0</span>, (<span class="hljs-keyword">struct</span> sockaddr*)&amp;broadcastAddr, <span class="hljs-keyword">sizeof</span>(broadcastAddr));<br></code></pre></td></tr></table></figure></p><p>组播 仅发送给主动加入组播组的设备。使用D类地址优点：高效节省带宽，适合大规模分发（如流媒体）组播对于客户端有一个IP_ADD_MEMBERSHIP过程，即加入组的过程</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>CS106L Learning</title>
    <link href="/2025/02/20/CS106L-Learning/"/>
    <url>/2025/02/20/CS106L-Learning/</url>
    
    <content type="html"><![CDATA[<h2 id="写在前面"><strong>写在前面</strong></h2>说实话，虽然我本科是计算机科班出身，但对C++的认识仍然只停留在cin和cout。<p>这次，由于国外的研究生比较闲，可以借这次机会好好学习一下c++<p><p>Telecomsudparis的课真是大粪，基本都是我本科学过的，而且他课上讲的真的不精，很多东西都是浅尝辄止，很难想象目前的欧洲教育体系下培养出来的学生真的能找到工作吗？</p><h2 id="type-and-structs">Type and Structs</h2><p>相比与C语言，c++多了一个新的结构体操作<code>std::pair&lt;T1, T2&gt;</code><br />接受两个类型的参数<br />应用场景:函数返回多个值，如<code>return &#123;a/b, true&#125;</code></p><p>可以用using来声明一个类型，例如 <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">using</span> QuadraticSolution = std::pair&lt;<span class="hljs-type">bool</span>, std::pair&lt;<span class="hljs-type">double</span>, <span class="hljs-type">double</span>&gt;&gt;;<br>QuadraticSolution‍ <span class="hljs-built_in">solveQuadratic</span>(<span class="hljs-type">double</span> a, <span class="hljs-type">double</span> b, <span class="hljs-type">double</span> c);<br></code></pre></td></tr></table></figure>用auto声明变量，可以自动推导一些变量的类型</p>]]></content>
    
    
    
  </entry>
  
  
  
  
</search>
